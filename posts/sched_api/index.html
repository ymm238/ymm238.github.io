<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>内核调度API | Ymm's 博客</title>
<meta name=keywords content="sched"><meta name=description content="Linux内核的调度模块（sched）是内核的核心组件之一，负责管理进程的CPU资源分配。以下是调度模块中核心接口的详细分析，内容分为多个部分，涵盖调度入口、调度类、上下文切换、优先级管理、CFS、负载均衡等关键功能。"><meta name=author content="ymm"><link rel=canonical href=https://ymm238.github.io/posts/sched_api/><meta name=google-site-verification content="YMM's BLOG"><meta name=yandex-verification content="YMM's BLOG"><meta name=msvalidate.01 content="YMM's BLOG"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://ymm238.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://ymm238.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://ymm238.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://ymm238.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://ymm238.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://ymm238.github.io/posts/sched_api/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="内核调度API"><meta property="og:description" content="Linux内核的调度模块（sched）是内核的核心组件之一，负责管理进程的CPU资源分配。以下是调度模块中核心接口的详细分析，内容分为多个部分，涵盖调度入口、调度类、上下文切换、优先级管理、CFS、负载均衡等关键功能。"><meta property="og:type" content="article"><meta property="og:url" content="https://ymm238.github.io/posts/sched_api/"><meta property="og:image" content="https://ymm238.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-14T11:30:03+00:00"><meta property="article:modified_time" content="2025-05-14T11:30:03+00:00"><meta property="og:site_name" content="ymm"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ymm238.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="内核调度API"><meta name=twitter:description content="Linux内核的调度模块（sched）是内核的核心组件之一，负责管理进程的CPU资源分配。以下是调度模块中核心接口的详细分析，内容分为多个部分，涵盖调度入口、调度类、上下文切换、优先级管理、CFS、负载均衡等关键功能。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ymm238.github.io/posts/"},{"@type":"ListItem","position":2,"name":"内核调度API","item":"https://ymm238.github.io/posts/sched_api/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"内核调度API","name":"内核调度API","description":"Linux内核的调度模块（sched）是内核的核心组件之一，负责管理进程的CPU资源分配。以下是调度模块中核心接口的详细分析，内容分为多个部分，涵盖调度入口、调度类、上下文切换、优先级管理、CFS、负载均衡等关键功能。\n","keywords":["sched"],"articleBody":"Linux内核的调度模块（sched）是内核的核心组件之一，负责管理进程的CPU资源分配。以下是调度模块中核心接口的详细分析，内容分为多个部分，涵盖调度入口、调度类、上下文切换、优先级管理、CFS、负载均衡等关键功能。\n1. 调度入口函数 1.1 schedule() 作用：调度器的核心入口函数，负责选择下一个要运行的进程并进行上下文切换。 调用时机： 进程主动放弃CPU（如调用 schedule_timeout、msleep、wait_event 等，注kmalloc接口gfp为GFP_KERNEL时在内存不足时会进入睡眠并重新调度，gfp为GFP_ATOMIC时不会睡眠，未申请到内存直接返回失败）。 进程被抢占（如实时进程唤醒或优先级反转）。 中断处理完成后返回用户态或内核态时触发调度。 调用链： schedule() -\u003e __schedule() // 实际调度逻辑 -\u003e pick_next_task() // 根据调度类选择下一个进程 -\u003e context_switch() // 执行上下文切换 1.2 preempt_schedule() 作用：内核抢占发生时的调度入口。 调用时机： 内核态代码允许抢占时（如 preempt_enable() 后）。 当前进程的 preempt_count 为0且被标记为需要重新调度（TIF_NEED_RESCHED）。 调用链： preempt_schedule() -\u003e __schedule() 1.3 schedule_timeout() 作用：使进程进入睡眠状态一段时间后自动唤醒。 调用时机： 进程调用 schedule_timeout() 或 msleep() 等函数。 调用链： schedule_timeout() -\u003e schedule() // 进入调度循环 -\u003e add_timer() // 添加超时定时器 2. 上下文切换 2.1 context_switch() 作用：完成进程上下文切换，包括寄存器状态保存和恢复。 调用时机： 在 schedule() 中被调用。 调用链： context_switch() -\u003e switch_mm() // 切换地址空间（MMU上下文） -\u003e switch_to() // 切换寄存器状态（汇编实现） 2.2 switch_to() 作用：底层寄存器切换，由汇编实现。 调用时机： context_switch() 中调用。 调用链： switch_to(prev, next, last) 3. 调度类接口 Linux调度器采用调度类（Scheduling Classes）分层设计，支持多种调度策略（CFS、RT、Deadline等）。每个调度类实现以下接口：\n3.1 enqueue_task() 作用：将进程加入运行队列（runqueue）。 调用时机： 进程被唤醒（try_to_wake_up()）。 新进程创建后首次加入队列。 调用链： try_to_wake_up() -\u003e enqueue_task() // 调用对应调度类的enqueue_task 3.2 dequeue_task() 作用：将进程从运行队列出队。 调用时机： 进程主动退出或进入阻塞状态。 调度策略变更（如从CFS切换到RT）。 调用链： deactivate_task() -\u003e dequeue_task() // 调用对应调度类的dequeue_task 3.3 pick_next_task() 作用：选择下一个要运行的进程。 调用时机： schedule() 中调用。 调用链： pick_next_task() -\u003e 调度类的pick_next_task方法（如CFS的pick_next_task_fair） 3.4 put_prev_task() 作用：释放当前进程的CPU使用权。 调用时机： __schedule() 中调用。 调用链： put_prev_task() -\u003e 调度类的put_prev_task方法 3.5 set_curr_task() 作用：更新运行队列的当前进程。 调用时机： 调度策略变更或进程迁移。 调用链： set_curr_task() -\u003e 调度类的set_curr_task方法 4. 优先级与调度策略 4.1 set_user_nice() 作用：调整进程的 nice 值，影响其动态优先级。 调用时机： 用户调用 nice() 系统调用。 内核通过 proc 文件系统修改 /proc//oom_adj。 调用链： sys_nice() -\u003e set_user_nice() 4.2 effective_prio() 作用：计算进程的有效优先级（考虑 nice 和调度策略）。 调用时机： 调度类（如CFS）在选择进程时调用。 调用链： effective_prio() -\u003e normal_prio() // 计算正常优先级 4.3 sched_setscheduler() 作用：设置进程的调度策略（如SCHED_FIFO、SCHED_RR、SCHED_DEADLINE）。 调用时机： 用户调用 sched_setscheduler() 系统调用。 调用链： sys_sched_setscheduler() -\u003e __sched_setscheduler() -\u003e 调度类的set_policy方法 5. 完全公平调度器（CFS） CFS是Linux默认的调度算法，基于红黑树维护可运行进程队列。\n5.1 enqueue_entity() 作用：将调度实体（se）加入CFS红黑树。 调用时机： 进程被唤醒（enqueue_task_fair() 调用）。 调用链： enqueue_task_fair() -\u003e enqueue_entity() -\u003e update_curr() // 更新当前进程的虚拟运行时间 5.2 dequeue_entity() 作用：将调度实体从CFS红黑树移除。 调用时机： 进程进入阻塞状态或退出。 调用链： dequeue_task_fair() -\u003e dequeue_entity() 5.3 update_curr() 作用：更新当前运行进程的虚拟运行时间（vruntime）。 调用时机： 时钟中断处理（scheduler_tick()）。 进程出队/入队时。 调用链： scheduler_tick() -\u003e update_curr() 5.4 calc_delta_fair() 作用：计算进程的虚拟运行时间增量。 调用时机： 进程执行时更新 vruntime。 调用链： update_curr() -\u003e calc_delta_fair() 6. 抢占与负载均衡 6.1 resched_curr() 作用：标记当前进程需要重新调度（设置 TIF_NEED_RESCHED）。 调用时机： 高优先级进程唤醒时（如实时进程）。 调用链： wake_up_new_task() -\u003e resched_curr() // 触发抢占 6.2 load_balance() 作用：在多核系统中平衡负载，迁移任务到空闲CPU。 调用时机： CPU空闲时调用 idle_balance()。 定时器中断触发负载均衡（如 nohz_balance_callback()）。 调用链： idle_balance() -\u003e load_balance() -\u003e pull_task() // 从其他CPU拉取任务 6.3 pull_task() 作用：从其他CPU的运行队列中迁移任务。 调用时机： load_balance() 中调用。 调用链： pull_task() -\u003e dequeue_task() // 从源CPU出队 -\u003e enqueue_task() // 在目标CPU入队 7. 唤醒与阻塞 7.1 try_to_wake_up() 作用：唤醒一个处于睡眠状态的进程。 调用时机： 进程等待的资源就绪（如I/O完成、信号量释放）。 调用链： try_to_wake_up() -\u003e enqueue_task() // 将进程加入运行队列 -\u003e resched_curr() // 可能触发抢占 7.2 wake_up_process() 作用：封装 try_to_wake_up() 的通用唤醒函数。 调用时机： 用户调用 wake_up_process() 显式唤醒进程。 调用链： wake_up_process() -\u003e try_to_wake_up() 8. 其他核心接口 8.1 scheduler_tick() 作用：时钟中断处理函数，更新调度器状态。 调用时机： 每个时钟滴答（tick）触发。 调用链： update_curr() -\u003e check_preempt_tick()// 检查是否需要抢占 8.2 schedule_hrtimeout() 作用：高精度定时睡眠（如 hrtimer）。 调用时机： 进程调用 schedule_hrtimeout()。 调用链： schedule_hrtimeout() -\u003e hrtimer_start() -\u003e schedule() 8.3 task_group() 作用：获取进程所属的cgroup调度组。 调用时机： CFS调度类中用于分组调度。 调用链： task_group() -\u003e css_lookup() // 获取cgroup子系统 总结 Linux调度模块的核心接口覆盖了进程调度、上下文切换、优先级管理、CFS算法、负载均衡等多个维度。这些接口协同工作，确保系统高效分配CPU资源。理解这些接口的作用和调用时机，有助于深入分析调度行为、优化系统性能或调试调度相关问题。\n","wordCount":"2298","inLanguage":"zh-cn","image":"https://ymm238.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-05-14T11:30:03Z","dateModified":"2025-05-14T11:30:03Z","author":{"@type":"Person","name":"ymm"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ymm238.github.io/posts/sched_api/"},"publisher":{"@type":"Organization","name":"Ymm's 博客","logo":{"@type":"ImageObject","url":"https://ymm238.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ymm238.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://ymm238.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ymm238.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ymm238.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ymm238.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">内核调度API</h1><div class=post-meta><span title='2025-05-14 11:30:03 +0000 +0000'>May 14, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;2298 words&nbsp;·&nbsp;ymm</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1-调度入口函数><strong>1. 调度入口函数</strong></a><ul><li><a href=#11><strong>1.1 <code>schedule()</code></strong></a></li><li><a href=#12><strong>1.2 <code>preempt_schedule()</code></strong></a></li><li><a href=#13><strong>1.3 <code>schedule_timeout()</code></strong></a></li></ul></li><li><a href=#2-上下文切换><strong>2. 上下文切换</strong></a><ul><li><a href=#21><strong>2.1 <code>context_switch()</code></strong></a></li><li><a href=#22><strong>2.2 <code>switch_to()</code></strong></a></li></ul></li><li><a href=#3-调度类接口><strong>3. 调度类接口</strong></a><ul><li><a href=#31><strong>3.1 <code>enqueue_task()</code></strong></a></li><li><a href=#32><strong>3.2 <code>dequeue_task()</code></strong></a></li><li><a href=#33><strong>3.3 <code>pick_next_task()</code></strong></a></li><li><a href=#34><strong>3.4 <code>put_prev_task()</code></strong></a></li><li><a href=#35><strong>3.5 <code>set_curr_task()</code></strong></a></li></ul></li><li><a href=#4-优先级与调度策略><strong>4. 优先级与调度策略</strong></a><ul><li><a href=#41><strong>4.1 <code>set_user_nice()</code></strong></a></li><li><a href=#42><strong>4.2 <code>effective_prio()</code></strong></a></li><li><a href=#43><strong>4.3 <code>sched_setscheduler()</code></strong></a></li></ul></li><li><a href=#5-完全公平调度器cfs><strong>5. 完全公平调度器（CFS）</strong></a><ul><li><a href=#51><strong>5.1 <code>enqueue_entity()</code></strong></a></li><li><a href=#52><strong>5.2 <code>dequeue_entity()</code></strong></a></li><li><a href=#53><strong>5.3 <code>update_curr()</code></strong></a></li><li><a href=#54><strong>5.4 <code>calc_delta_fair()</code></strong></a></li></ul></li><li><a href=#6-抢占与负载均衡><strong>6. 抢占与负载均衡</strong></a><ul><li><a href=#61><strong>6.1 <code>resched_curr()</code></strong></a></li><li><a href=#62><strong>6.2 <code>load_balance()</code></strong></a></li><li><a href=#63><strong>6.3 <code>pull_task()</code></strong></a></li></ul></li><li><a href=#7-唤醒与阻塞><strong>7. 唤醒与阻塞</strong></a><ul><li><a href=#71><strong>7.1 <code>try_to_wake_up()</code></strong></a></li><li><a href=#72><strong>7.2 <code>wake_up_process()</code></strong></a></li></ul></li><li><a href=#8-其他核心接口><strong>8. 其他核心接口</strong></a><ul><li><a href=#81><strong>8.1 <code>scheduler_tick()</code></strong></a></li><li><a href=#82><strong>8.2 <code>schedule_hrtimeout()</code></strong></a></li><li><a href=#83><strong>8.3 <code>task_group()</code></strong></a></li></ul></li><li><a href=#总结><strong>总结</strong></a></li></ul></nav></div></details></div><div class=post-content><p>Linux内核的调度模块（<code>sched</code>）是内核的核心组件之一，负责管理进程的CPU资源分配。以下是调度模块中<strong>核心接口</strong>的详细分析，内容分为多个部分，涵盖调度入口、调度类、上下文切换、优先级管理、CFS、负载均衡等关键功能。</p><hr><h2 id=1-调度入口函数><strong>1. 调度入口函数</strong><a hidden class=anchor aria-hidden=true href=#1-调度入口函数>#</a></h2><h3 id=11><strong>1.1 <code>schedule()</code></strong><a hidden class=anchor aria-hidden=true href=#11>#</a></h3><ul><li><strong>作用</strong>：调度器的核心入口函数，负责选择下一个要运行的进程并进行上下文切换。</li><li><strong>调用时机</strong>：<ul><li>进程主动放弃CPU（如调用 <code>schedule_timeout</code>、<code>msleep</code>、<code>wait_event</code> 等，注kmalloc接口gfp为<strong>GFP_KERNEL</strong>时在内存不足时会<strong>进入睡眠并重新调度</strong>，gfp为<strong>GFP_ATOMIC</strong>时不会睡眠，未申请到内存直接返回失败）。</li><li>进程被抢占（如实时进程唤醒或优先级反转）。</li><li>中断处理完成后返回用户态或内核态时触发调度。</li></ul></li><li><strong>调用链</strong>：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>schedule()
</span></span><span class=line><span class=cl>-&gt; __schedule()          // 实际调度逻辑
</span></span><span class=line><span class=cl>    -&gt; pick_next_task()   // 根据调度类选择下一个进程
</span></span><span class=line><span class=cl>    -&gt; context_switch()   // 执行上下文切换
</span></span></code></pre></div><h3 id=12><strong>1.2 <code>preempt_schedule()</code></strong><a hidden class=anchor aria-hidden=true href=#12>#</a></h3><ul><li><strong>作用</strong>：内核抢占发生时的调度入口。</li><li><strong>调用时机</strong>：<ul><li>内核态代码允许抢占时（如 <code>preempt_enable()</code> 后）。</li><li>当前进程的 <code>preempt_count</code> 为0且被标记为需要重新调度（<code>TIF_NEED_RESCHED</code>）。</li></ul></li><li><strong>调用链</strong>：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>preempt_schedule()
</span></span><span class=line><span class=cl>-&gt; __schedule()
</span></span></code></pre></div><h3 id=13><strong>1.3 <code>schedule_timeout()</code></strong><a hidden class=anchor aria-hidden=true href=#13>#</a></h3><ul><li><strong>作用</strong>：使进程进入睡眠状态一段时间后自动唤醒。</li><li><strong>调用时机</strong>：<ul><li>进程调用 <code>schedule_timeout()</code> 或 <code>msleep()</code> 等函数。</li></ul></li><li><strong>调用链</strong>：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>schedule_timeout()
</span></span><span class=line><span class=cl>-&gt; schedule()           // 进入调度循环
</span></span><span class=line><span class=cl>-&gt; add_timer()         // 添加超时定时器
</span></span></code></pre></div><hr><h2 id=2-上下文切换><strong>2. 上下文切换</strong><a hidden class=anchor aria-hidden=true href=#2-上下文切换>#</a></h2><h3 id=21><strong>2.1 <code>context_switch()</code></strong><a hidden class=anchor aria-hidden=true href=#21>#</a></h3><ul><li><strong>作用</strong>：完成进程上下文切换，包括寄存器状态保存和恢复。</li><li><strong>调用时机</strong>：<ul><li>在 <code>schedule()</code> 中被调用。</li></ul></li><li><strong>调用链</strong>：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>context_switch()
</span></span><span class=line><span class=cl>-&gt; switch_mm()         // 切换地址空间（MMU上下文）
</span></span><span class=line><span class=cl>-&gt; switch_to()         // 切换寄存器状态（汇编实现）
</span></span></code></pre></div><h3 id=22><strong>2.2 <code>switch_to()</code></strong><a hidden class=anchor aria-hidden=true href=#22>#</a></h3><ul><li><strong>作用</strong>：底层寄存器切换，由汇编实现。</li><li><strong>调用时机</strong>：<ul><li><code>context_switch()</code> 中调用。</li></ul></li><li><strong>调用链</strong>：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>switch_to(prev, next, last)
</span></span></code></pre></div><hr><h2 id=3-调度类接口><strong>3. 调度类接口</strong><a hidden class=anchor aria-hidden=true href=#3-调度类接口>#</a></h2><p>Linux调度器采用<strong>调度类</strong>（Scheduling Classes）分层设计，支持多种调度策略（CFS、RT、Deadline等）。每个调度类实现以下接口：</p><h3 id=31><strong>3.1 <code>enqueue_task()</code></strong><a hidden class=anchor aria-hidden=true href=#31>#</a></h3><ul><li><strong>作用</strong>：将进程加入运行队列（runqueue）。</li><li><strong>调用时机</strong>：<ul><li>进程被唤醒（<code>try_to_wake_up()</code>）。</li><li>新进程创建后首次加入队列。</li></ul></li><li><strong>调用链</strong>：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>try_to_wake_up()
</span></span><span class=line><span class=cl>-&gt; enqueue_task()       // 调用对应调度类的enqueue_task
</span></span></code></pre></div><h3 id=32><strong>3.2 <code>dequeue_task()</code></strong><a hidden class=anchor aria-hidden=true href=#32>#</a></h3><ul><li><strong>作用</strong>：将进程从运行队列出队。</li><li><strong>调用时机</strong>：<ul><li>进程主动退出或进入阻塞状态。</li><li>调度策略变更（如从CFS切换到RT）。</li></ul></li><li><strong>调用链</strong>：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>deactivate_task()
</span></span><span class=line><span class=cl>-&gt; dequeue_task()       // 调用对应调度类的dequeue_task
</span></span></code></pre></div><h3 id=33><strong>3.3 <code>pick_next_task()</code></strong><a hidden class=anchor aria-hidden=true href=#33>#</a></h3><ul><li><strong>作用</strong>：选择下一个要运行的进程。</li><li><strong>调用时机</strong>：<ul><li><code>schedule()</code> 中调用。</li></ul></li><li><strong>调用链</strong>：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>pick_next_task()
</span></span><span class=line><span class=cl>-&gt; 调度类的pick_next_task方法（如CFS的pick_next_task_fair）
</span></span></code></pre></div><h3 id=34><strong>3.4 <code>put_prev_task()</code></strong><a hidden class=anchor aria-hidden=true href=#34>#</a></h3><ul><li><strong>作用</strong>：释放当前进程的CPU使用权。</li><li><strong>调用时机</strong>：<ul><li><code>__schedule()</code> 中调用。</li></ul></li><li><strong>调用链</strong>：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>put_prev_task()
</span></span><span class=line><span class=cl>-&gt; 调度类的put_prev_task方法
</span></span></code></pre></div><h3 id=35><strong>3.5 <code>set_curr_task()</code></strong><a hidden class=anchor aria-hidden=true href=#35>#</a></h3><ul><li><strong>作用</strong>：更新运行队列的当前进程。</li><li><strong>调用时机</strong>：<ul><li>调度策略变更或进程迁移。</li></ul></li><li><strong>调用链</strong>：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>set_curr_task()
</span></span><span class=line><span class=cl>-&gt; 调度类的set_curr_task方法
</span></span></code></pre></div><hr><h2 id=4-优先级与调度策略><strong>4. 优先级与调度策略</strong><a hidden class=anchor aria-hidden=true href=#4-优先级与调度策略>#</a></h2><h3 id=41><strong>4.1 <code>set_user_nice()</code></strong><a hidden class=anchor aria-hidden=true href=#41>#</a></h3><ul><li><strong>作用</strong>：调整进程的 <code>nice</code> 值，影响其动态优先级。</li><li><strong>调用时机</strong>：<ul><li>用户调用 <code>nice()</code> 系统调用。</li><li>内核通过 <code>proc</code> 文件系统修改 <code>/proc/&lt;pid>/oom_adj</code>。</li></ul></li><li><strong>调用链</strong>：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>sys_nice()
</span></span><span class=line><span class=cl>-&gt; set_user_nice()
</span></span></code></pre></div><h3 id=42><strong>4.2 <code>effective_prio()</code></strong><a hidden class=anchor aria-hidden=true href=#42>#</a></h3><ul><li><strong>作用</strong>：计算进程的有效优先级（考虑 <code>nice</code> 和调度策略）。</li><li><strong>调用时机</strong>：<ul><li>调度类（如CFS）在选择进程时调用。</li></ul></li><li><strong>调用链</strong>：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>effective_prio()
</span></span><span class=line><span class=cl>-&gt; normal_prio()       // 计算正常优先级
</span></span></code></pre></div><h3 id=43><strong>4.3 <code>sched_setscheduler()</code></strong><a hidden class=anchor aria-hidden=true href=#43>#</a></h3><ul><li><strong>作用</strong>：设置进程的调度策略（如SCHED_FIFO、SCHED_RR、SCHED_DEADLINE）。</li><li><strong>调用时机</strong>：<ul><li>用户调用 <code>sched_setscheduler()</code> 系统调用。</li></ul></li><li><strong>调用链</strong>：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>sys_sched_setscheduler()
</span></span><span class=line><span class=cl>-&gt; __sched_setscheduler()
</span></span><span class=line><span class=cl>    -&gt; 调度类的set_policy方法
</span></span></code></pre></div><hr><h2 id=5-完全公平调度器cfs><strong>5. 完全公平调度器（CFS）</strong><a hidden class=anchor aria-hidden=true href=#5-完全公平调度器cfs>#</a></h2><p>CFS是Linux默认的调度算法，基于红黑树维护可运行进程队列。</p><h3 id=51><strong>5.1 <code>enqueue_entity()</code></strong><a hidden class=anchor aria-hidden=true href=#51>#</a></h3><ul><li><strong>作用</strong>：将调度实体（<code>se</code>）加入CFS红黑树。</li><li><strong>调用时机</strong>：<ul><li>进程被唤醒（<code>enqueue_task_fair()</code> 调用）。</li></ul></li><li><strong>调用链</strong>：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>enqueue_task_fair()
</span></span><span class=line><span class=cl>-&gt; enqueue_entity()
</span></span><span class=line><span class=cl>    -&gt; update_curr()     // 更新当前进程的虚拟运行时间
</span></span></code></pre></div><h3 id=52><strong>5.2 <code>dequeue_entity()</code></strong><a hidden class=anchor aria-hidden=true href=#52>#</a></h3><ul><li><strong>作用</strong>：将调度实体从CFS红黑树移除。</li><li><strong>调用时机</strong>：<ul><li>进程进入阻塞状态或退出。</li></ul></li><li><strong>调用链</strong>：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>dequeue_task_fair()
</span></span><span class=line><span class=cl>-&gt; dequeue_entity()
</span></span></code></pre></div><h3 id=53><strong>5.3 <code>update_curr()</code></strong><a hidden class=anchor aria-hidden=true href=#53>#</a></h3><ul><li><strong>作用</strong>：更新当前运行进程的虚拟运行时间（<code>vruntime</code>）。</li><li><strong>调用时机</strong>：<ul><li>时钟中断处理（<code>scheduler_tick()</code>）。</li><li>进程出队/入队时。</li></ul></li><li><strong>调用链</strong>：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>scheduler_tick()
</span></span><span class=line><span class=cl>-&gt; update_curr()
</span></span></code></pre></div><h3 id=54><strong>5.4 <code>calc_delta_fair()</code></strong><a hidden class=anchor aria-hidden=true href=#54>#</a></h3><ul><li><strong>作用</strong>：计算进程的虚拟运行时间增量。</li><li><strong>调用时机</strong>：<ul><li>进程执行时更新 <code>vruntime</code>。</li></ul></li><li><strong>调用链</strong>：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>update_curr()
</span></span><span class=line><span class=cl>-&gt; calc_delta_fair()
</span></span></code></pre></div><hr><h2 id=6-抢占与负载均衡><strong>6. 抢占与负载均衡</strong><a hidden class=anchor aria-hidden=true href=#6-抢占与负载均衡>#</a></h2><h3 id=61><strong>6.1 <code>resched_curr()</code></strong><a hidden class=anchor aria-hidden=true href=#61>#</a></h3><ul><li><strong>作用</strong>：标记当前进程需要重新调度（设置 <code>TIF_NEED_RESCHED</code>）。</li><li><strong>调用时机</strong>：<ul><li>高优先级进程唤醒时（如实时进程）。</li></ul></li><li><strong>调用链</strong>：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>wake_up_new_task()
</span></span><span class=line><span class=cl>-&gt; resched_curr()       // 触发抢占
</span></span></code></pre></div><h3 id=62><strong>6.2 <code>load_balance()</code></strong><a hidden class=anchor aria-hidden=true href=#62>#</a></h3><ul><li><strong>作用</strong>：在多核系统中平衡负载，迁移任务到空闲CPU。</li><li><strong>调用时机</strong>：<ul><li>CPU空闲时调用 <code>idle_balance()</code>。</li><li>定时器中断触发负载均衡（如 <code>nohz_balance_callback()</code>）。</li></ul></li><li><strong>调用链</strong>：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>idle_balance()
</span></span><span class=line><span class=cl>-&gt; load_balance()
</span></span><span class=line><span class=cl>    -&gt; pull_task()       // 从其他CPU拉取任务
</span></span></code></pre></div><h3 id=63><strong>6.3 <code>pull_task()</code></strong><a hidden class=anchor aria-hidden=true href=#63>#</a></h3><ul><li><strong>作用</strong>：从其他CPU的运行队列中迁移任务。</li><li><strong>调用时机</strong>：<ul><li><code>load_balance()</code> 中调用。</li></ul></li><li><strong>调用链</strong>：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>pull_task()
</span></span><span class=line><span class=cl>-&gt; dequeue_task()      // 从源CPU出队
</span></span><span class=line><span class=cl>-&gt; enqueue_task()      // 在目标CPU入队
</span></span></code></pre></div><hr><h2 id=7-唤醒与阻塞><strong>7. 唤醒与阻塞</strong><a hidden class=anchor aria-hidden=true href=#7-唤醒与阻塞>#</a></h2><h3 id=71><strong>7.1 <code>try_to_wake_up()</code></strong><a hidden class=anchor aria-hidden=true href=#71>#</a></h3><ul><li><strong>作用</strong>：唤醒一个处于睡眠状态的进程。</li><li><strong>调用时机</strong>：<ul><li>进程等待的资源就绪（如I/O完成、信号量释放）。</li></ul></li><li><strong>调用链</strong>：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>try_to_wake_up()
</span></span><span class=line><span class=cl>-&gt; enqueue_task()      // 将进程加入运行队列
</span></span><span class=line><span class=cl>-&gt; resched_curr()      // 可能触发抢占
</span></span></code></pre></div><h3 id=72><strong>7.2 <code>wake_up_process()</code></strong><a hidden class=anchor aria-hidden=true href=#72>#</a></h3><ul><li><strong>作用</strong>：封装 <code>try_to_wake_up()</code> 的通用唤醒函数。</li><li><strong>调用时机</strong>：<ul><li>用户调用 <code>wake_up_process()</code> 显式唤醒进程。</li></ul></li><li><strong>调用链</strong>：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>wake_up_process()
</span></span><span class=line><span class=cl>-&gt; try_to_wake_up()
</span></span></code></pre></div><hr><h2 id=8-其他核心接口><strong>8. 其他核心接口</strong><a hidden class=anchor aria-hidden=true href=#8-其他核心接口>#</a></h2><h3 id=81><strong>8.1 <code>scheduler_tick()</code></strong><a hidden class=anchor aria-hidden=true href=#81>#</a></h3><ul><li><strong>作用</strong>：时钟中断处理函数，更新调度器状态。</li><li><strong>调用时机</strong>：<ul><li>每个时钟滴答（tick）触发。</li></ul></li><li><strong>调用链</strong>：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>update_curr()
</span></span><span class=line><span class=cl>-&gt; check_preempt_tick()// 检查是否需要抢占
</span></span></code></pre></div><h3 id=82><strong>8.2 <code>schedule_hrtimeout()</code></strong><a hidden class=anchor aria-hidden=true href=#82>#</a></h3><ul><li><strong>作用</strong>：高精度定时睡眠（如 <code>hrtimer</code>）。</li><li><strong>调用时机</strong>：<ul><li>进程调用 <code>schedule_hrtimeout()</code>。</li></ul></li><li><strong>调用链</strong>：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>schedule_hrtimeout()
</span></span><span class=line><span class=cl>-&gt; hrtimer_start()
</span></span><span class=line><span class=cl>-&gt; schedule()
</span></span></code></pre></div><h3 id=83><strong>8.3 <code>task_group()</code></strong><a hidden class=anchor aria-hidden=true href=#83>#</a></h3><ul><li><strong>作用</strong>：获取进程所属的cgroup调度组。</li><li><strong>调用时机</strong>：<ul><li>CFS调度类中用于分组调度。</li></ul></li><li><strong>调用链</strong>：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>task_group()
</span></span><span class=line><span class=cl>-&gt; css_lookup()        // 获取cgroup子系统
</span></span></code></pre></div><hr><h2 id=总结><strong>总结</strong><a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>Linux调度模块的核心接口覆盖了进程调度、上下文切换、优先级管理、CFS算法、负载均衡等多个维度。这些接口协同工作，确保系统高效分配CPU资源。理解这些接口的作用和调用时机，有助于深入分析调度行为、优化系统性能或调试调度相关问题。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ymm238.github.io/tags/sched/>Sched</a></li></ul><nav class=paginav><a class=next href=https://ymm238.github.io/posts/sched_class/><span class=title>»</span><br><span>sched class简介</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://ymm238.github.io/>Ymm's 博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>
<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>sched class简介 | Ymm's 博客</title>
<meta name=keywords content="kernel,sched"><meta name=description content="Linux内核调度类解析：面向对象设计的精妙实践
  在Linux内核中，调度类（Scheduler Class） 是调度器实现的核心抽象机制。它通过模块化的设计，将不同类型的任务调度策略解耦，同时兼顾实时性、公平性和资源分配的效率。这种设计不仅体现了内核开发者对复杂系统需求的深刻理解，还展现了面向对象思想在C语言中的巧妙实践。调度器相关代码位于kernel/sched/目录下。"><meta name=author content="ymm"><link rel=canonical href=https://ymm238.github.io/posts/sched_class/><meta name=google-site-verification content="YMM's BLOG"><meta name=yandex-verification content="YMM's BLOG"><meta name=msvalidate.01 content="YMM's BLOG"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://ymm238.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://ymm238.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://ymm238.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://ymm238.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://ymm238.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://ymm238.github.io/posts/sched_class/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="sched class简介"><meta property="og:description" content="Linux内核调度类解析：面向对象设计的精妙实践
  在Linux内核中，调度类（Scheduler Class） 是调度器实现的核心抽象机制。它通过模块化的设计，将不同类型的任务调度策略解耦，同时兼顾实时性、公平性和资源分配的效率。这种设计不仅体现了内核开发者对复杂系统需求的深刻理解，还展现了面向对象思想在C语言中的巧妙实践。调度器相关代码位于kernel/sched/目录下。"><meta property="og:type" content="article"><meta property="og:url" content="https://ymm238.github.io/posts/sched_class/"><meta property="og:image" content="https://ymm238.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-09T13:30:03+00:00"><meta property="article:modified_time" content="2025-05-09T13:30:03+00:00"><meta property="og:site_name" content="ymm"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ymm238.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="sched class简介"><meta name=twitter:description content="Linux内核调度类解析：面向对象设计的精妙实践
  在Linux内核中，调度类（Scheduler Class） 是调度器实现的核心抽象机制。它通过模块化的设计，将不同类型的任务调度策略解耦，同时兼顾实时性、公平性和资源分配的效率。这种设计不仅体现了内核开发者对复杂系统需求的深刻理解，还展现了面向对象思想在C语言中的巧妙实践。调度器相关代码位于kernel/sched/目录下。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ymm238.github.io/posts/"},{"@type":"ListItem","position":2,"name":"sched class简介","item":"https://ymm238.github.io/posts/sched_class/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"sched class简介","name":"sched class简介","description":"Linux内核调度类解析：面向对象设计的精妙实践 在Linux内核中，调度类（Scheduler Class） 是调度器实现的核心抽象机制。它通过模块化的设计，将不同类型的任务调度策略解耦，同时兼顾实时性、公平性和资源分配的效率。这种设计不仅体现了内核开发者对复杂系统需求的深刻理解，还展现了面向对象思想在C语言中的巧妙实践。调度器相关代码位于kernel/sched/目录下。\n","keywords":["kernel","sched"],"articleBody":"Linux内核调度类解析：面向对象设计的精妙实践 在Linux内核中，调度类（Scheduler Class） 是调度器实现的核心抽象机制。它通过模块化的设计，将不同类型的任务调度策略解耦，同时兼顾实时性、公平性和资源分配的效率。这种设计不仅体现了内核开发者对复杂系统需求的深刻理解，还展现了面向对象思想在C语言中的巧妙实践。调度器相关代码位于kernel/sched/目录下。\n一、调度类的定义与作用 调度类是一组策略和操作的集合，用于管理特定类型任务的调度行为。每个调度类对应一种调度策略，内核通过优先级顺序依次调用这些类，确保高优先级任务优先执行。以6.6内核为例，sched_class的定义方式如下\n/* sched_class数据结构的成员变量均为函数指针 */ struct sched_class { void (*enqueue_task) (struct rq *rq, struct task_struct *p, int flags); void (*dequeue_task) (struct rq *rq, struct task_struct *p, int flags); void (*yield_task) (struct rq *rq); struct task_struct *(*pick_next_task)(struct rq *rq); void (*put_prev_task)(struct rq *rq, struct task_struct *p); void (*set_next_task)(struct rq *rq, struct task_struct *p, bool first); }; /* 由宏定义某一特定调度类 */ #define DEFINE_SCHED_CLASS(name) \\ const struct sched_class name##_sched_class \\ __aligned(__alignof__(struct sched_class)) \\ __section(\"__\" #name \"_sched_class\") /* CFS调度器类的定义实现如下 */ DEFINE_SCHED_CLASS(fair) = { .enqueue_tas = enqueue_task_fair, .dequeue_task = dequeue_task_fair, .yield_task = yield_task_fair, .pick_next_task = __pick_next_task_fair, .put_prev_task = put_prev_task_fair, .set_next_task = set_next_task_fair, ... }; 调度类优先级定义方式如下\n#define SCHED_DATA \\ STRUCT_ALIGN(); \\ __sched_class_highest = .; \\ *(__stop_sched_class) \\ *(__dl_sched_class) \\ *(__rt_sched_class) \\ *(__fair_sched_class) \\ *(__idle_sched_class) \\ __sched_class_lowest = .; #define for_each_class(class) \\ for_class_range(class, __sched_class_highest, __sched_class_lowest) 目前Linux内核包含五大调度类（优先级从高到低）：\nstop_sched_class：处理紧急任务（如CPU热插拔），抢占所有其他进程。 dl_sched_class（Deadline调度类）：基于截止时间的实时调度，适用于周期性硬实时任务。 rt_sched_class：实时调度类，支持SCHED_FIFO（先进先出）和SCHED_RR（时间片轮转）策略。 fair_sched_class（CFS调度类）：完全公平调度算法，管理普通进程（如SCHED_NORMAL和SCHED_BATCH）。 idle_sched_class：空闲调度类，仅在所有CPU无任务时运行。 二、调度器类核心接口 在Linux内核中，调度器类（struct sched_class）通过一组函数指针定义了不同调度策略（如CFS、实时调度等）的核心行为。任务（struct task_struc）数据结构包含其当前使用的sched_class成员变量，所以对接口的调用方式均如下\n/* 将p加入到rq中 */ p-\u003esched_class-\u003eenqueue_task(rq, p, flags); 以下是其核心接口及其作用：\n任务队列管理接口 enqueue_task\n作用：将进程加入就绪队列（例如CFS的红黑树或实时调度的优先级链表）。 触发场景：进程从阻塞状态变为可运行状态时调用，例如通过wake_up()唤醒进程。 dequeue_task\n作用：将进程从就绪队列中移除。 触发场景：进程进入阻塞状态或优先级调整时（例如调用setpriority()修改优先级）。 调度决策接口 pick_next_task\n作用：从就绪队列中选择下一个要运行的进程。 实现逻辑： CFS调度器选择红黑树中虚拟时间（vruntime）最小的进程。 实时调度器优先选择优先级最高的实时进程。 check_preempt_curr\n作用：检查新唤醒的进程是否需要抢占当前进程。 典型场景：实时进程唤醒时，若其优先级高于当前进程，触发抢占。 yield_task\n作用：主动让出CPU（例如调用sched_yield()系统调用）。 效果：将进程重新加入队列尾部，避免长时间占用CPU。 上下文切换与状态更新接口 put_prev_task\n作用：在切换进程前，更新当前进程的调度状态（例如更新CFS的vruntime）。 触发时机：调度器准备切换到新进程时调用。 task_tick\n作用：周期性调度的核心函数，由时钟中断触发（例如时钟触发后调用scheduler_tick）。 功能： 更新进程时间片（CFS中更新vruntime）。 检查是否需要重新调度（例如设置TIF_NEED_RESCHED标志）。 优先级与策略管理接口 prio_changed\n作用：响应进程优先级变化（例如通过setpriority()调整优先级）。 实现：实时调度类需重新排序队列，CFS调度类需重新计算虚拟时间权重。 switch_to（间接关联，封装到特定体系结构的目录）\n作用：执行底层上下文切换（如寄存器状态保存/恢复）。 关联函数：context_switch()中调用switch_mm()和switch_to()完成硬件级切换。 三、面向对象思想的体现 尽管Linux内核使用C语言实现，但调度类的设计高度模拟了面向对象（OO）的抽象机制，具体体现在以下方面：\n封装与多态\n每个调度类通过struct sched_class结构体定义，包含enqueue_task（入队）、pick_next_task（选择任务）等函数指针。 例如，CFS调度类通过fair_sched_class实现公平调度逻辑，而实时调度类通过rt_sched_class处理优先级抢占。 继承与扩展性\n内核通过链表串联所有调度类（stop → dl → rt → fair → idle），形成优先级链，调度时按顺序遍历。 新增调度类（如2014年引入的Deadline类）只需实现自身逻辑，无需修改核心调度框架。 策略与机制分离\n公共调度逻辑（如上下文切换）由核心代码（schedule()函数）处理，具体策略由各调度类实现。 例如，CFS通过虚拟时间（vruntime）计算进程优先级，而Deadline类基于任务周期和截止时间分配CPU。 四、总结 Linux内核调度类的设计是机制与策略分离的典范。通过面向对象的思想，它将复杂的调度逻辑分解为可扩展的模块，既保证了实时任务的严格性，又实现了普通任务的公平性。这种设计哲学不仅适用于操作系统内核，也为其他系统软件架构提供了重要参考。\n","wordCount":"2190","inLanguage":"zh-cn","image":"https://ymm238.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-05-09T13:30:03Z","dateModified":"2025-05-09T13:30:03Z","author":{"@type":"Person","name":"ymm"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ymm238.github.io/posts/sched_class/"},"publisher":{"@type":"Organization","name":"Ymm's 博客","logo":{"@type":"ImageObject","url":"https://ymm238.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ymm238.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://ymm238.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ymm238.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ymm238.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ymm238.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">sched class简介</h1><div class=post-meta><span title='2025-05-09 13:30:03 +0000 +0000'>May 9, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;2190 words&nbsp;·&nbsp;ymm</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#linux内核调度类解析面向对象设计的精妙实践>Linux内核调度类解析：面向对象设计的精妙实践</a><ul><li><a href=#一调度类的定义与作用>一、调度类的定义与作用</a></li><li><a href=#二调度器类核心接口>二、调度器类核心接口</a></li><li><a href=#三面向对象思想的体现>三、面向对象思想的体现</a></li><li><a href=#四总结>四、总结</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=linux内核调度类解析面向对象设计的精妙实践>Linux内核调度类解析：面向对象设计的精妙实践<a hidden class=anchor aria-hidden=true href=#linux内核调度类解析面向对象设计的精妙实践>#</a></h2><p>  在Linux内核中，<strong>调度类（Scheduler Class）</strong> 是调度器实现的核心抽象机制。它通过模块化的设计，将不同类型的任务调度策略解耦，同时兼顾实时性、公平性和资源分配的效率。这种设计不仅体现了内核开发者对复杂系统需求的深刻理解，还展现了面向对象思想在C语言中的巧妙实践。调度器相关代码位于<code>kernel/sched/</code>目录下。</p><hr><h3 id=一调度类的定义与作用>一、调度类的定义与作用<a hidden class=anchor aria-hidden=true href=#一调度类的定义与作用>#</a></h3><p>调度类是一组<strong>策略和操作的集合</strong>，用于管理特定类型任务的调度行为。每个调度类对应一种调度策略，内核通过优先级顺序依次调用这些类，确保高优先级任务优先执行。以6.6内核为例，sched_class的定义方式如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* sched_class数据结构的成员变量均为函数指针 */</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>sched_class</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>enqueue_task</span><span class=p>)</span> <span class=p>(</span><span class=k>struct</span> <span class=n>rq</span> <span class=o>*</span><span class=n>rq</span><span class=p>,</span> <span class=k>struct</span> <span class=n>task_struct</span> <span class=o>*</span><span class=n>p</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>dequeue_task</span><span class=p>)</span> <span class=p>(</span><span class=k>struct</span> <span class=n>rq</span> <span class=o>*</span><span class=n>rq</span><span class=p>,</span> <span class=k>struct</span> <span class=n>task_struct</span> <span class=o>*</span><span class=n>p</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>yield_task</span><span class=p>)</span>   <span class=p>(</span><span class=k>struct</span> <span class=n>rq</span> <span class=o>*</span><span class=n>rq</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>task_struct</span> <span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>pick_next_task</span><span class=p>)(</span><span class=k>struct</span> <span class=n>rq</span> <span class=o>*</span><span class=n>rq</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>put_prev_task</span><span class=p>)(</span><span class=k>struct</span> <span class=n>rq</span> <span class=o>*</span><span class=n>rq</span><span class=p>,</span> <span class=k>struct</span> <span class=n>task_struct</span> <span class=o>*</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>set_next_task</span><span class=p>)(</span><span class=k>struct</span> <span class=n>rq</span> <span class=o>*</span><span class=n>rq</span><span class=p>,</span> <span class=k>struct</span> <span class=n>task_struct</span> <span class=o>*</span><span class=n>p</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>first</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* 由宏定义某一特定调度类 */</span>
</span></span><span class=line><span class=cl><span class=cp>#define DEFINE_SCHED_CLASS(name) \
</span></span></span><span class=line><span class=cl><span class=cp>const struct sched_class name##_sched_class \
</span></span></span><span class=line><span class=cl><span class=cp>    __aligned(__alignof__(struct sched_class)) \
</span></span></span><span class=line><span class=cl><span class=cp>    __section(&#34;__&#34; #name &#34;_sched_class&#34;)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* CFS调度器类的定义实现如下 */</span>
</span></span><span class=line><span class=cl><span class=nf>DEFINE_SCHED_CLASS</span><span class=p>(</span><span class=n>fair</span><span class=p>)</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>enqueue_tas</span>    <span class=o>=</span> <span class=n>enqueue_task_fair</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>dequeue_task</span>   <span class=o>=</span> <span class=n>dequeue_task_fair</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>yield_task</span>     <span class=o>=</span> <span class=n>yield_task_fair</span><span class=p>,</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>pick_next_task</span>    <span class=o>=</span> <span class=n>__pick_next_task_fair</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>put_prev_task</span>     <span class=o>=</span> <span class=n>put_prev_task_fair</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>set_next_task</span>     <span class=o>=</span> <span class=n>set_next_task_fair</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>调度类优先级定义方式如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define SCHED_DATA              \
</span></span></span><span class=line><span class=cl><span class=cp>    STRUCT_ALIGN();             \
</span></span></span><span class=line><span class=cl><span class=cp>    __sched_class_highest = .;      \
</span></span></span><span class=line><span class=cl><span class=cp>    *(__stop_sched_class)           \
</span></span></span><span class=line><span class=cl><span class=cp>    *(__dl_sched_class)         \
</span></span></span><span class=line><span class=cl><span class=cp>    *(__rt_sched_class)         \
</span></span></span><span class=line><span class=cl><span class=cp>    *(__fair_sched_class)           \
</span></span></span><span class=line><span class=cl><span class=cp>    *(__idle_sched_class)           \
</span></span></span><span class=line><span class=cl><span class=cp>    __sched_class_lowest = .;
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define for_each_class(class) \
</span></span></span><span class=line><span class=cl><span class=cp>    for_class_range(class, __sched_class_highest, __sched_class_lowest)
</span></span></span></code></pre></div><p>目前Linux内核包含五大调度类（优先级从高到低）：</p><ol><li><strong>stop_sched_class</strong>：处理紧急任务（如CPU热插拔），抢占所有其他进程。</li><li><strong>dl_sched_class</strong>（Deadline调度类）：基于截止时间的实时调度，适用于周期性硬实时任务。</li><li><strong>rt_sched_class</strong>：实时调度类，支持<code>SCHED_FIFO</code>（先进先出）和<code>SCHED_RR</code>（时间片轮转）策略。</li><li><strong>fair_sched_class</strong>（CFS调度类）：完全公平调度算法，管理普通进程（如<code>SCHED_NORMAL</code>和<code>SCHED_BATCH</code>）。</li><li><strong>idle_sched_class</strong>：空闲调度类，仅在所有CPU无任务时运行。</li></ol><hr><h3 id=二调度器类核心接口>二、调度器类核心接口<a hidden class=anchor aria-hidden=true href=#二调度器类核心接口>#</a></h3><p>在Linux内核中，调度器类（<code>struct sched_class</code>）通过一组<strong>函数指针</strong>定义了不同调度策略（如CFS、实时调度等）的核心行为。任务（<code>struct task_struc</code>）数据结构包含其当前使用的sched_class成员变量，所以对接口的调用方式均如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* 将p加入到rq中 */</span>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=o>-&gt;</span><span class=n>sched_class</span><span class=o>-&gt;</span><span class=nf>enqueue_task</span><span class=p>(</span><span class=n>rq</span><span class=p>,</span> <span class=n>p</span><span class=p>,</span> <span class=n>flags</span><span class=p>);</span>
</span></span></code></pre></div><p>以下是其核心接口及其作用：</p><h4 id=任务队列管理接口><strong>任务队列管理接口</strong><a hidden class=anchor aria-hidden=true href=#任务队列管理接口>#</a></h4><ol><li><p><strong>enqueue_task</strong></p><ul><li><strong>作用</strong>：将进程加入就绪队列（例如CFS的红黑树或实时调度的优先级链表）。</li><li><strong>触发场景</strong>：进程从阻塞状态变为可运行状态时调用，例如通过<code>wake_up()</code>唤醒进程。</li></ul></li><li><p><strong>dequeue_task</strong></p><ul><li><strong>作用</strong>：将进程从就绪队列中移除。</li><li><strong>触发场景</strong>：进程进入阻塞状态或优先级调整时（例如调用<code>setpriority()</code>修改优先级）。</li></ul></li></ol><h4 id=调度决策接口><strong>调度决策接口</strong><a hidden class=anchor aria-hidden=true href=#调度决策接口>#</a></h4><ol><li><p><strong>pick_next_task</strong></p><ul><li><strong>作用</strong>：从就绪队列中选择下一个要运行的进程。</li><li><strong>实现逻辑</strong>：<ul><li>CFS调度器选择红黑树中虚拟时间（<code>vruntime</code>）最小的进程。</li><li>实时调度器优先选择优先级最高的实时进程。</li></ul></li></ul></li><li><p><strong>check_preempt_curr</strong></p><ul><li><strong>作用</strong>：检查新唤醒的进程是否需要抢占当前进程。</li><li><strong>典型场景</strong>：实时进程唤醒时，若其优先级高于当前进程，触发抢占。</li></ul></li><li><p><strong>yield_task</strong></p><ul><li><strong>作用</strong>：主动让出CPU（例如调用<code>sched_yield()</code>系统调用）。</li><li><strong>效果</strong>：将进程重新加入队列尾部，避免长时间占用CPU。</li></ul></li></ol><h4 id=上下文切换与状态更新接口><strong>上下文切换与状态更新接口</strong><a hidden class=anchor aria-hidden=true href=#上下文切换与状态更新接口>#</a></h4><ol><li><p><strong>put_prev_task</strong></p><ul><li><strong>作用</strong>：在切换进程前，更新当前进程的调度状态（例如更新CFS的<code>vruntime</code>）。</li><li><strong>触发时机</strong>：调度器准备切换到新进程时调用。</li></ul></li><li><p><strong>task_tick</strong></p><ul><li><strong>作用</strong>：周期性调度的核心函数，由时钟中断触发（例如时钟触发后调用<code>scheduler_tick</code>）。</li><li><strong>功能</strong>：<ul><li>更新进程时间片（CFS中更新<code>vruntime</code>）。</li><li>检查是否需要重新调度（例如设置<code>TIF_NEED_RESCHED</code>标志）。</li></ul></li></ul></li></ol><h4 id=优先级与策略管理接口><strong>优先级与策略管理接口</strong><a hidden class=anchor aria-hidden=true href=#优先级与策略管理接口>#</a></h4><ol><li><p><strong>prio_changed</strong></p><ul><li><strong>作用</strong>：响应进程优先级变化（例如通过<code>setpriority()</code>调整优先级）。</li><li><strong>实现</strong>：实时调度类需重新排序队列，CFS调度类需重新计算虚拟时间权重。</li></ul></li><li><p><strong>switch_to</strong>（间接关联，封装到特定体系结构的目录）</p><ul><li><strong>作用</strong>：执行底层上下文切换（如寄存器状态保存/恢复）。</li><li><strong>关联函数</strong>：<code>context_switch()</code>中调用<code>switch_mm()</code>和<code>switch_to()</code>完成硬件级切换。</li></ul></li></ol><h3 id=三面向对象思想的体现>三、面向对象思想的体现<a hidden class=anchor aria-hidden=true href=#三面向对象思想的体现>#</a></h3><p>尽管Linux内核使用C语言实现，但调度类的设计<strong>高度模拟了面向对象（OO）的抽象机制</strong>，具体体现在以下方面：</p><ol><li><p><strong>封装与多态</strong></p><ul><li>每个调度类通过<code>struct sched_class</code>结构体定义，包含<code>enqueue_task</code>（入队）、<code>pick_next_task</code>（选择任务）等函数指针。</li><li>例如，CFS调度类通过<code>fair_sched_class</code>实现公平调度逻辑，而实时调度类通过<code>rt_sched_class</code>处理优先级抢占。</li></ul></li><li><p><strong>继承与扩展性</strong></p><ul><li>内核通过链表串联所有调度类（<code>stop → dl → rt → fair → idle</code>），形成<strong>优先级链</strong>，调度时按顺序遍历。</li><li>新增调度类（如2014年引入的Deadline类）只需实现自身逻辑，无需修改核心调度框架。</li></ul></li><li><p><strong>策略与机制分离</strong></p><ul><li>公共调度逻辑（如上下文切换）由核心代码（<code>schedule()</code>函数）处理，具体策略由各调度类实现。</li><li>例如，CFS通过虚拟时间（<code>vruntime</code>）计算进程优先级，而Deadline类基于任务周期和截止时间分配CPU。</li></ul></li></ol><hr><h3 id=四总结>四、总结<a hidden class=anchor aria-hidden=true href=#四总结>#</a></h3><p>Linux内核调度类的设计是<strong>机制与策略分离的典范</strong>。通过面向对象的思想，它将复杂的调度逻辑分解为可扩展的模块，既保证了实时任务的严格性，又实现了普通任务的公平性。这种设计哲学不仅适用于操作系统内核，也为其他系统软件架构提供了重要参考。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ymm238.github.io/tags/kernel/>Kernel</a></li><li><a href=https://ymm238.github.io/tags/sched/>Sched</a></li></ul><nav class=paginav><a class=next href=https://ymm238.github.io/posts/modules/><span class=title>»</span><br><span>模块加载与卸载</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://ymm238.github.io/>Ymm's 博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>
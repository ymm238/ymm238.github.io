<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Ymm&#39;s 博客</title>
    <link>https://ymm238.github.io/</link>
    <description>Recent content on Ymm&#39;s 博客</description>
    <image>
      <title>Ymm&#39;s 博客</title>
      <url>https://ymm238.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://ymm238.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.145.0</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 19 May 2025 11:30:03 +0000</lastBuildDate>
    <atom:link href="https://ymm238.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>用户态进程地址空间</title>
      <link>https://ymm238.github.io/posts/addr_space/</link>
      <pubDate>Mon, 19 May 2025 11:30:03 +0000</pubDate>
      <guid>https://ymm238.github.io/posts/addr_space/</guid>
      <description>&lt;h2 id=&#34;用户态进程地址空间&#34;&gt;用户态进程地址空间&lt;/h2&gt;
&lt;h2 id=&#34;用户地址空间架构&#34;&gt;用户地址空间架构&lt;/h2&gt;
&lt;p&gt;用户空间是Linux进程地址空间中与应用程序直接交互的核心区域，其组成结构既是操作系统内存管理的艺术体现，也是程序运行的物质基础。在3GB（32位系统）或128TB（64位系统）的虚拟地址范围内，用户空间通过&lt;strong&gt;六大核心区域&lt;/strong&gt;实现代码执行、数据存储和动态扩展功能（）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>内核调度API</title>
      <link>https://ymm238.github.io/posts/sched_api/</link>
      <pubDate>Wed, 14 May 2025 11:30:03 +0000</pubDate>
      <guid>https://ymm238.github.io/posts/sched_api/</guid>
      <description>&lt;p&gt;Linux内核的调度模块（&lt;code&gt;sched&lt;/code&gt;）是内核的核心组件之一，负责管理进程的CPU资源分配。以下是调度模块中&lt;strong&gt;核心接口&lt;/strong&gt;的详细分析，内容分为多个部分，涵盖调度入口、调度类、上下文切换、优先级管理、CFS、负载均衡等关键功能。&lt;/p&gt;</description>
    </item>
    <item>
      <title>sched class简介</title>
      <link>https://ymm238.github.io/posts/sched_class/</link>
      <pubDate>Fri, 09 May 2025 13:30:03 +0000</pubDate>
      <guid>https://ymm238.github.io/posts/sched_class/</guid>
      <description>&lt;h2 id=&#34;linux内核调度类解析面向对象设计的精妙实践&#34;&gt;Linux内核调度类解析：面向对象设计的精妙实践&lt;/h2&gt;
&lt;p&gt;  在Linux内核中，&lt;strong&gt;调度类（Scheduler Class）&lt;/strong&gt; 是调度器实现的核心抽象机制。它通过模块化的设计，将不同类型的任务调度策略解耦，同时兼顾实时性、公平性和资源分配的效率。这种设计不仅体现了内核开发者对复杂系统需求的深刻理解，还展现了面向对象思想在C语言中的巧妙实践。调度器相关代码位于&lt;code&gt;kernel/sched/&lt;/code&gt;目录下。&lt;/p&gt;</description>
    </item>
    <item>
      <title>模块加载与卸载</title>
      <link>https://ymm238.github.io/posts/modules/</link>
      <pubDate>Fri, 09 May 2025 11:30:03 +0000</pubDate>
      <guid>https://ymm238.github.io/posts/modules/</guid>
      <description>&lt;p&gt;在Linux内核开发中，模块化设计允许开发者动态扩展内核功能而无需重新编译整个内核。本文将深入解析模块的加载与卸载、参数传递机制，以及如何编写高效的Makefile，帮助开发者快速上手内核模块开发。&lt;/p&gt;</description>
    </item>
    <item>
      <title>MMU、TLB 和页表：核心概念解析</title>
      <link>https://ymm238.github.io/posts/mmu/</link>
      <pubDate>Mon, 28 Apr 2025 17:30:03 +0000</pubDate>
      <guid>https://ymm238.github.io/posts/mmu/</guid>
      <description>&lt;h2 id=&#34;mmutlb-和页表核心概念解析&#34;&gt;&lt;strong&gt;MMU、TLB 和页表：核心概念解析&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在计算机系统中，&lt;strong&gt;内存管理单元（MMU）&lt;/strong&gt;、&lt;strong&gt;页表（Page Table）&lt;/strong&gt; 和 &lt;strong&gt;转换后备缓冲器（TLB）&lt;/strong&gt; 共同协作，实现虚拟内存到物理内存的高效映射。以下是它们的核心逻辑和交互关系：&lt;/p&gt;</description>
    </item>
    <item>
      <title>kernel代码阅读生产力 -- vim plug、Cscope</title>
      <link>https://ymm238.github.io/posts/vim_plug/</link>
      <pubDate>Thu, 13 Mar 2025 09:40:28 +0000</pubDate>
      <guid>https://ymm238.github.io/posts/vim_plug/</guid>
      <description>&lt;p&gt;  Vim 是一个Linux上功能强大的文本编辑器，通过安装插件，你可以将Vim打造成一个功能齐全的IDE。vim-plug 是一个轻量级且易于使用的插件管理器，能够帮助用户轻松安装、更新和删除插件。本文将介绍如何在Linux系统上安装和使用 vim-plug 来管理你的 Vim 插件。本人vim配置可见&lt;a href=&#34;https://github.com/ymm238/vimrc&#34;&gt;vimrc&lt;/a&gt;。使用vim相关插件配合Cscope看内核代码将流畅起飞！&lt;/p&gt;</description>
    </item>
    <item>
      <title>C语言运算符优先级及注意事项</title>
      <link>https://ymm238.github.io/posts/shift_operator/</link>
      <pubDate>Thu, 09 Jan 2025 09:23:03 +0000</pubDate>
      <guid>https://ymm238.github.io/posts/shift_operator/</guid>
      <description>&lt;p&gt;  该博客主要记录C语言优先级使用时的易错点。&lt;/p&gt;
&lt;h2 id=&#34;常见运算符优先级对比&#34;&gt;常见运算符优先级对比&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;运算符&lt;/th&gt;
          &lt;th&gt;优先级&lt;/th&gt;
          &lt;th&gt;示例&lt;/th&gt;
          &lt;th&gt;解释&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;()&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;(a + b) * c&lt;/td&gt;
          &lt;td&gt;先计算括号内的表达式&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;[]&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;arr[0]&lt;/td&gt;
          &lt;td&gt;先访问数组元素&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;++ &amp;ndash;&lt;/td&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;num++&lt;/td&gt;
          &lt;td&gt;num = num + 1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;* &amp;amp;&lt;/td&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;*address&lt;/td&gt;
          &lt;td&gt;取address处地址的值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;* / %&lt;/td&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;a * b + c&lt;/td&gt;
          &lt;td&gt;先进行乘法，再进行加法&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;+ -&lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;a + b * c&lt;/td&gt;
          &lt;td&gt;先进行乘法，再进行加法&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&amp;laquo; &amp;raquo;&lt;/td&gt;
          &lt;td&gt;6&lt;/td&gt;
          &lt;td&gt;a &amp;laquo; b + c&lt;/td&gt;
          &lt;td&gt;先进行加法，再进行左移&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&amp;lt; &amp;lt;= &amp;gt; &amp;gt;=&lt;/td&gt;
          &lt;td&gt;7&lt;/td&gt;
          &lt;td&gt;a &amp;lt; b &amp;amp;&amp;amp; c &amp;gt; d&lt;/td&gt;
          &lt;td&gt;先比较，再进行逻辑与&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;== !=&lt;/td&gt;
          &lt;td&gt;8&lt;/td&gt;
          &lt;td&gt;a == b&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&amp;amp;&amp;amp;&lt;/td&gt;
          &lt;td&gt;12&lt;/td&gt;
          &lt;td&gt;a &amp;amp;&amp;amp; b&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;``&lt;/td&gt;
          &lt;td&gt;13&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;?:&lt;/td&gt;
          &lt;td&gt;14&lt;/td&gt;
          &lt;td&gt;a &amp;gt; b ? a : b&lt;/td&gt;
          &lt;td&gt;先判断条件，再执行对应的分支&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;=&lt;/td&gt;
          &lt;td&gt;15&lt;/td&gt;
          &lt;td&gt;a = b = c&lt;/td&gt;
          &lt;td&gt;从右到左赋值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;,&lt;/td&gt;
          &lt;td&gt;16&lt;/td&gt;
          &lt;td&gt;a = (b++, c++)&lt;/td&gt;
          &lt;td&gt;从左到右依次执行，返回最后一个值&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;常见误区&#34;&gt;常见误区&lt;/h2&gt;
&lt;h3 id=&#34;位移运算符&#34;&gt;位移运算符&lt;/h3&gt;
&lt;p&gt;  左移、右移优先级是低于加减运算的，如以下代码为：&lt;/p&gt;</description>
    </item>
    <item>
      <title>KBuild中内核编译顺序</title>
      <link>https://ymm238.github.io/posts/kbuild_make_order/</link>
      <pubDate>Tue, 09 Jul 2024 11:30:03 +0000</pubDate>
      <guid>https://ymm238.github.io/posts/kbuild_make_order/</guid>
      <description>&lt;h2 id=&#34;问题背景&#34;&gt;问题背景&lt;/h2&gt;
&lt;p&gt;  近日在解决一个i2c驱动问题时发现奇怪的现象，两个相同内核的不同i2c驱动在/dev下创建的字符设备id不同。 简化如下表格&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;/th&gt;
          &lt;th&gt;系统A&lt;/th&gt;
          &lt;th&gt;系统B&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;ismt&lt;/td&gt;
          &lt;td&gt;i2c-0&lt;/td&gt;
          &lt;td&gt;i2c-1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;i801&lt;/td&gt;
          &lt;td&gt;i2c-1&lt;/td&gt;
          &lt;td&gt;i2c-0&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;  系统A为通过iso直接罐装的发行版系统，系统B为定制化业务系统。系统B上层业务代码需要使用i2c-0字符设备且要保证为ismt总线（关键硬件挂载在ismt总线），所以需要将系统B中i2c-0与ismt总线绑定。起初通过修改两个i2c驱动源码，将i2c设备添加接口i2c_add_adapter接口更改为i2c_add_numbered_adapter，使其与id静态绑定满足上述需求。但因为发现两个系统id不同的根本原因，所以继续调研跟踪。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
